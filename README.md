# LookAndSay

### 해결 과정
문제의 내용 중
"수 1211은 '1개의 1, 1개의 2, 2개의 1'이다."
"수 111221은 '3개의 1, 2개의 2, 1개의 1'이다."
"수 312211은 '1개의 3, 1개의 1, 2개의 2, 2개의 1'이다."
...
의 내용을 보고 가장 먼저 떠오른 것은 객체를 통한 관리였습니다.

> try 1
``` Java
private static class NumObj {
        private byte target;
        private byte count;
        public NumObj(int target, int count) {
                this.target = (byte) target;
                this.count = (byte) count;
        }
}
```
객체를 통해 관리하더라도 "1개의 1, 1개의 2" 이런 식으로 서로 다른 객체에서 연속된 숫자가 등장할 수 있다는 것을 생각하여 이 방법은 선택하지 않고,
다음으로 생각한 것은 List를 통한 관리였습니다.

> try 2
``` Java
List<Byte> currArr = new ArrayList<>();
currArr.add((byte) 1);
//...(logic)
//result : [1] [1, 1] [2, 1] [1, 2, 1, 1] [1, 1, 1, 2, 2, 1] ...
```
그 후 숫자를 출력해보며 테스트를 해본 결과
```
1  : 1
2  : 11
3  : 21
4  : 1211
5  : 111221
6  : 312211
7  : 13112221
8  : 1113213211
9  : 31131211131221
10 : 13211311123113112211
11 : 11131221133112132113212221
12 : 3113112221232112111312211312113211
13 : 1321132132111213122112311311222113111221131221
14 : 11131221131211131231121113112221121321132132211331222113112211
15 : 311311222113111231131112132112311321322112111312211312111322212311322113212221
16 : 132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211
...
```
객체와 List의 문제가 아님을 깨닫게 됩니다.
10번 이상을 돌려보니 길이가 기하급수적으로 커지는 것을 깨닫고, 방법을 바꿔 생각해봅니다.
